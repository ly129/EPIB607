"cutoff = -0.5400 + 0.0059 = -0.5341",
adj=c(0,0.5),cex=0.65)
arrows(-0.540,-0.25*ht, crit.value,-0.25*ht,
length=0.05, angle=20,col=Green)
I=0
for ( pct.w in seq(0,3,0.25) ){
mu = mu.m*(100-pct.w)/100
if(pct.w==3) text(-0.52,-ht/1.3,"Added Water",
cex=0.75, adj=c(0,0.5))
green= seq(mu-3*SEM,crit.value,length.out=50)
d = c(dnorm(green,mu,SEM),0)
polygon(c(green,crit.value),d + I*ht,col=Green,border=NA)
red= seq(crit.value,mu+3*SEM,length.out=50)
d = c(dnorm(red,mu,SEM),0)
polygon(c(red,crit.value),d + I*ht,col="red",border=NA)
text(mu+3*SEM, I*ht,
toString(
round(100*pnorm(crit.value,mu,SEM,lower.tail=FALSE)) ),
col="red")
if(I==0) text(mu-2*SEM, (I+0.5)*ht,
toString(
round(100*pnorm(crit.value,mu,SEM)) ),
col=Green)
points(mu,I*ht,pch=19,
cex=0.25+0.4*(pct.w==round(pct.w)) )
points(mu,-ht*1.0,pch=19,cex=0.25)
if(pct.w==round(pct.w)) text(mu,-ht/1.3,
paste(toString(pct.w),"%"),cex=0.75)
if(pct.w==round(pct.w)) points(mu,
-ht*1.0,pch=19,cex=0.75)
if(I==0) text(-0.54,-1.15*ht,
"MILK",adj=c(0.5,1) )
I = I+1
}
} # fig1
fig2= FALSE
if(fig2){
# 1% fixed , vary n
ht=1.6*dnorm(0,0,sigma/sqrt(20))
mu.1pct = 0.99* mu.m
par(mfrow=c(1,1),mar = c(5,0.001,0.001,0.001) )
plot(c(mu.m-4.25*SEM,mu.1pct+3*SEM),c(-1.5*ht,16*ht),
col="white",xlab="Freezing point (degrees C)")
segments(mu.1pct,0,mu.1pct,
12*ht,lwd=0.5,col="grey60")
text(-0.51,3*ht,"Probability (pct.)
of exceeding cutoff",adj=c(1,0),col="red")
text(-0.555,16*ht,
expression(paste(
sigma,
" = 0.0080;  SEM = ",
sigma/sqrt(n))) ,
adj=c(0,0))
text(-0.555,15*ht,
"cutoff = -0.54 + 1.645*SEM (alpha=0.05, 1 sided alternative)",
adj=c(0,0))
text(-0.555,16*ht,
expression(paste(
sigma,
" = 0.0080;  SEM = ",
sigma/sqrt(n))) ,
adj=c(0,0))
n=5
sem = sigma/sqrt(n)
n80 = round(( ( 1.645+0.84)^2 ) * (sigma/0.0054)^2,1)
I=0
for ( m in c(1:2,n80/5,3,4) ){
if(m==1) text(-0.52,-ht/2,"Added Water",
cex=0.75, adj=c(0,0.5))
SEM = sem/sqrt(m)
text(-0.55,(I+1.0)*ht,
paste("n =",toString(n*m)) ,
adj=c(1,0))
crit.value = mu.m + 1.646 * SEM
rect(mu.m-4*sem,(I-0.8)*ht, mu.1pct+3*sem,(I+2.2)*ht)
# null
green= seq(mu.m-3*SEM,crit.value,length.out=50)
d = c(dnorm(green,mu.m,SEM),0)
polygon(c(green,crit.value),d + I*ht,col=Green,border=NA)
text(-0.548,(I+1.0)*ht,
paste("SEM = ",
toString(round(SEM,4))),
cex=0.65,adj=c(0,0))
red= seq(crit.value,mu.m+3*SEM,length.out=50)
d = c(dnorm(red,mu.m,SEM),0)
polygon(c(red,crit.value),d + I*ht,col="red",border=NA)
points(mu.m,I*ht,cex=0.3,pch=19)
#alt
green= seq(mu.1pct-3*SEM,
crit.value,length.out=50)
d = c(dnorm(green,mu.1pct,SEM),0)
polygon(c(green,crit.value),d + (I+1)*ht,col=Green,border=NA)
points(mu.1pct,(I+1)*ht,cex=0.3,pch=19)
red= seq(crit.value,mu.1pct+3*SEM,length.out=50)
d = c(dnorm(red,mu.1pct,SEM),0)
polygon(c(red,crit.value),d + (I+1)*ht,col="red",border=NA)
segments(crit.value,I*ht ,
crit.value,(I+1)*ht,lwd=0.5,col="red")
arrows(mu.m,(I-0.25)*ht,
crit.value,(I-0.25)*ht,length=0.05,
code=3,angle=20,col=Green,lwd=1.5)
arrows(crit.value,(I+1-0.25)*ht,
mu.1pct,(I+1-0.25)*ht,length=0.05,
code=3,angle=15,col="red",lwd=1.5)
x = mu.1pct+1*SEM
y = (I+1)*ht+0.8*max(d)
if(m!=round(m))rect(
x - 0.0011,y-0.10*ht,
x + 0.0011,y+0.60*ht,
col="beige",border="purple",
lwd=2)
text(x, y,
paste(toString( round(100*pnorm(
crit.value,mu.1pct,
SEM,lower.tail=FALSE)) ),"%",sep=""),
adj=c(0.5,0),col="red")
if(m!=round(m)){
text(-0.5305,(I+1.55)*ht,"qnorm(0.8,
lower.tail=FALSE)
-0.84",		cex=0.65,family="mono",adj=c(0,0.5),col="red")
x = (crit.value+mu.1pct)/2
lines(x+c(0,0,0.005),
(I+1-0.25+c(0,-.3,-.3))*ht,col="red")
text(x+0.005,
(I+1-0.25-0.3)*ht,
"0.84 * SEM",col="red",
adj=c(-0.1,0.5),cex=0.65)
text(-0.553,(I-0.4)*ht,"qnorm(0.05,
lower.tail=FALSE)
1.96",		cex=0.65,family="mono",adj=c(0,0),col=Green)
x = (crit.value+mu.m)/2
lines(x+c(0,0,-0.005),
(I-0.25+c(0,-.15,-.15))*ht,col=Green)
text(x-0.005,
(I-0.25-0.15)*ht,
"1.645 * SEM",col=Green,
adj=c(1.1,0),cex=0.65)
sum <- "(1.645 + 0.84)"
txt = substitute(
paste("n = ",
s^2,
phantom(0),
scriptstyle(x),
phantom(0),
(sigma/Delta)^2),
list(s = sum))
rect(-0.554,(I+1.55)*ht,
-0.5445,(I+2.17)*ht,
col="beige",border="purple",
lwd=4)
text(-0.553,(I+1.6)*ht,txt,
adj=c(0,0), cex=0.75)
arrows(mu.m,   (I-0.6)*ht,
mu.1pct,(I-0.6)*ht,length=0.05,
code=3,angle=20,lwd=1.5)
text(mu.1pct,(I-0.6)*ht,
expression(paste(
Delta, " = 1.645*SEM + 0.84*SEM")),
adj=c(-0.1,0.5), cex=0.75
)
} # special
I = I+3
}
n80 = ( ( 1.645+0.84)^2 ) * (sigma/0.0054)^2
points(mu.m,   -1.5*ht,pch=19,cex=0.65 )
text(mu.m,-ht,"100% milk",cex=0.75)
points(mu.1pct,-1.5*ht,pch=19,cex=0.65)
text(mu.1pct,-ht,"1 % water",cex=0.75)
text((mu.m+mu.1pct)/2,-1.5*ht,
expression(paste(Delta," = 0.0054")),
cex=0.85)
arrows(mu.m,-1.8*ht,
mu.1pct,-1.8*ht,length=0.05,
code=3,angle=20,lwd=1.5)
} # end fig 2
mosaic::t_test(~age, HELPrct)
n <- length(reaction.times)
SEM <- sd(reaction.times)/sqrt(n)
reaction.times <- c(325,327,357,299,378)/1000
n <- length(reaction.times)
SEM <- sd(reaction.times)/sqrt(n)
n <- length(reaction.times)
SEM <- sd(reaction.times)/sqrt(n)
(SEM <- sd(reaction.times)/sqrt(n))
multiple.for.95pct <- stats::qt(p = c(0.025, 0.975), df = n-1)
(multiple.for.95pct <- stats::qt(p = c(0.025, 0.975), df = n-1))
by_hand_CI <- mean(reaction.times) + multiple.for.95pct * SEM
round(by_hand_CI, 3)
qt(p = c(0.025, 0.975), df = n-1, ncp = mean(reaction.times)/SEM)
qt(p = c(0.025, 0.975), df = n-1, ncp = mean(reaction.times)*SEM)
qt(p = c(0.025, 0.975), df = n-1, ncp = SEM/mean(reaction.times))
coef(fit)
fit <- stats::lm(reaction.times ~ 1)
summary(fit)
stats::confint(fit)
coef(fit)
mosaic::xpt(q = c(-24.56, 24.56), df = n-1)
mosaic::xpt(q = c(-24.56, 24.56), df = n-1, lower.tail=F)
mosaic::xpt(q = 24.56, df = n-1, lower.tail=F)
mosaic::t.test(reaction.times ~ 1)
mosaic::t.test(reaction.times)
mosaic::t.test(reaction.times~1)
mosaic::t.test(reaction.times~0)
mosaic::t.test(reaction.times~1)
mosaic::t.test(reaction.times)
lm(~reaction.times)
lm(reaction.times)
lm(reaction.times~)
lm(reaction.times~1)
s_dist <- do(10000) * mean( ~ reaction.times, data = resample(reaction.times))
df_react <- as.data.frame(reaction.times)
df_react
s_dist <- do(10000) * mean( ~ reaction.times, data = resample(df_react))
# 95% CI
CI_95 <- quantile(~ mean, data = s_dist, probs = c(0.025, 0.975))
# plot sampling distribution
hist(s_dist$mean, breaks = 50, col = "#56B4E9",
main="",
xlab = "mean depth of the ocean (100m) from each bootstrap sample")
# draw red line at the sample mean
abline(v = mean_depth, lty =1, col = "red", lwd = 4)
# draw red line at the sample mean
abline(v = mean(reaction.times), lty =1, col = "red", lwd = 4)
# draw black dotted lines at 95% CI
abline(v = CI_95[1], lty =2, col = "black", lwd = 4)
abline(v = CI_95[2], lty =2, col = "black", lwd = 4)
# include legend
library(latex2exp)
mean(reaction.times)
# include legend
library(latex2exp)
legend("topleft",
legend = c(TeX("$\\bar{y} = 0.3372$"),
sprintf("95%% CI: [%.3f, %.3f]",CI_95[1], CI_95[2])),
lty = c(1,1),
col = c("red","black"), lwd = 4)
data.frame(reaction.times)
dev.off()
pacman::p_ver("roxygen2")
install.packages("roxygen2")
reaction.times <- c(325,327,357,299,378)/1000
summary(reaction.times)
round(sd(reaction.times),3)
length(reaction.times)
n <- length(reaction.times)
SEM <- sd(reaction.times)/sqrt(n)
(SEM <- sd(reaction.times)/sqrt(n))
multiple.for.95pct <- stats::qt(p = c(0.025, 0.975), df = n-1)
(multiple.for.95pct <- stats::qt(p = c(0.025, 0.975), df = n-1))
by_hand_CI <- mean(reaction.times) + multiple.for.95pct * SEM
round(by_hand_CI, 3)
fit <- stats::lm(reaction.times ~ 1)
summary(fit)
stats::confint(fit)
fit <- stats::lm(reaction.times ~ 1)
summary(fit)
stats::confint(fit)
SEM
qt(p = c(0.025, 0.975), df = 2*SEM / (SEM-1))
dt_ls <- function(x, df, mu, a) 1/a * dt((x - mu)/a, df)
pt_ls <- function(x, df, mu, a) pt((x - mu)/a, df)
qt_ls <- function(prob, df, mu, a) qt(prob, df)*a + mu
rt_ls <- function(n, df, mu, a) rt(n,df)*a + mu
qt_ls(prob = c(0.025, 0.975), df = n - 1, mu = mean(reaction.times), a = SEM)
256-266
-10/(16/20^0.5)
pnorm(-0.625)
df <- as.data.frame(rbind(
c("[1. Live Poll](http://etc.ch/tfZA)"),
c("[2. DALITE Q5](https://github.com/sahirbhatnagar/EPIB607/raw/master/dalite/005_hypothesis_t/005-hypothesis-t-sol.pdf)"),
c("[3. Bootstrap Confidence Intervals](https://github.com/sahirbhatnagar/EPIB607/raw/master/slides/bootstrap/EPIB607_bootstrap.pdf)"),
c("[4. Bootstrap article in Scientific American](https://www.dropbox.com/s/cxiq70zxxtyxlb5/EfronDiaconisBootstrap.pdf?dl=0)"),
c("[5. Overview Grid](https://www.dropbox.com/s/t7a1bnxdid9y6i3/OverviewGrid.pdf?dl=0)"),
c("[6. Inference about a population mean ($\\mu$)](https://github.com/sahirbhatnagar/EPIB607/raw/master/slides/one_sample_mean/EPIB607_one_sample_mean.pdf)")
))
df %>% kable(col.names = NULL) %>%
kable_styling(bootstrap_options = c("striped", "hover"))
weight <- read.csv("weight_gain.csv")
weight <- read.csv("assignment/a5/weight_gain.csv")
weight <- read.csv("assignments/a5/weight_gain.csv")
head(weight)
knitr::kable(weight)
weight <- read.csv("~/git_repositories/epib607/assignments/a5/weightgain.csv")
knitr::kable(weight)
weight$diff <- weight$after - weight$before
s_dist <- do(10000) * mean(~ diff, data = resample(weight))
library(mosaic)
s_dist <- do(10000) * mean(~ diff, data = resample(weight))
hist(s_dist$mean)
moon <- load("~/Downloads/FullMoon.RData")
moon
load("/home/sahir/Downloads/FullMoon.RData")
FullMoon
FullMoon$aggdiff <- NULL
FullMoon
colnames(FullMoon) <- c("patient","moon_days", "other_days")
write.csv(FullMoon, file = "fullmoon.csv", quote = FALSE, row.names = FALSE, col.names = TRUE)
write.csv(FullMoon, file = "fullmoon.csv", quote = FALSE, row.names = FALSE)
fullmoon <- read.csv("fullmoon.csv")
fullmoon <- read.csv("~/git_repositories/epib607/assignments/a5/fullmoon.csv")
fullmoon
str(fullmoon)
# moon <- load("~/Downloads/FullMoon.RData")
# FullMoon$aggdiff <- NULL
# colnames(FullMoon) <- c("patient","moon_days", "other_days")
# write.csv(FullMoon, file = "fullmoon.csv", quote = FALSE, row.names = FALSE)
fullmoon <- read.csv("~/git_repositories/epib607/assignments/a5/fullmoon.csv")
head(fullmoon)
fullmoon$diff <- fullmoon$moon_days - fullmoon$other_days
s_dist <- do(10000) * mean(~ diff, data = resample(fullmoon))
hist(s_dist$mean)
compare_CI <- function(ybar, QNORM, BOOT, TPROCEDURE,
col = c("#E41A1C","#377EB8","#4DAF4A")) {
dt <- data.frame(type = c("qnorm", "bootstrap", "t"),
ybar = rep(ybar, 3),
low = c(QNORM[1], BOOT[1], TPROCEDURE[1]),
up = c(QNORM[2], BOOT[2], TPROCEDURE[1])
)
plot(dt$ybar, 1:nrow(dt), pch = 20, ylim = c(0, 5),
xlim = range(pretty(c(dt$low, dt$up))),
xlab = "Depth of ocean (m)", ylab = "Confidence Interval Type",
las = 1, cex.axis = 0.8, cex = 3)
abline(v = 37, lty = 2, col = "black", lwd = 2)
segments(x0 = dt$low, x1 = dt$up,
y0 = 1:nrow(dt), lend = 1,
col = col, lwd = 4)
legend("topleft",
legend = c(eval(substitute( expression(paste(mu," = ",37))))
sprintf("qnorm CI: [%.f, %.f]",QNORM[1], QNORM[2]),
sprintf("bootstrap CI: [%.f, %.f]",BOOT[1], BOOT[2]),
sprintf("t CI: [%.f, %.f]",TPROCEDURE[1], TPROCEDURE[2])),
lty = c(1,1,1,1),
col = c("black",col), lwd = 4)
}
compare_CI <- function(ybar, QNORM, BOOT, TPROCEDURE,
col = c("#E41A1C","#377EB8","#4DAF4A")) {
dt <- data.frame(type = c("qnorm", "bootstrap", "t"),
ybar = rep(ybar, 3),
low = c(QNORM[1], BOOT[1], TPROCEDURE[1]),
up = c(QNORM[2], BOOT[2], TPROCEDURE[1])
)
plot(dt$ybar, 1:nrow(dt), pch = 20, ylim = c(0, 5),
xlim = range(pretty(c(dt$low, dt$up))),
xlab = "Depth of ocean (m)", ylab = "Confidence Interval Type",
las = 1, cex.axis = 0.8, cex = 3)
abline(v = 37, lty = 2, col = "black", lwd = 2)
segments(x0 = dt$low, x1 = dt$up,
y0 = 1:nrow(dt), lend = 1,
col = col, lwd = 4)
legend("topleft",
legend = c(eval(substitute( expression(paste(mu," = ",37))))
sprintf("qnorm CI: [%.f, %.f]",QNORM[1], QNORM[2]),
sprintf("bootstrap CI: [%.f, %.f]",BOOT[1], BOOT[2]),
sprintf("t CI: [%.f, %.f]",TPROCEDURE[1], TPROCEDURE[2])),
lty = c(1,1,1,1),
col = c("black",col), lwd = 4)
}
compare_CI <- function(ybar, QNORM, BOOT, TPROCEDURE,
col = c("#E41A1C","#377EB8","#4DAF4A")) {
dt <- data.frame(type = c("qnorm", "bootstrap", "t"),
ybar = rep(ybar, 3),
low = c(QNORM[1], BOOT[1], TPROCEDURE[1]),
up = c(QNORM[2], BOOT[2], TPROCEDURE[1])
)
plot(dt$ybar, 1:nrow(dt), pch = 20, ylim = c(0, 5),
xlim = range(pretty(c(dt$low, dt$up))),
xlab = "Depth of ocean (m)", ylab = "Confidence Interval Type",
las = 1, cex.axis = 0.8, cex = 3)
abline(v = 37, lty = 2, col = "black", lwd = 2)
segments(x0 = dt$low, x1 = dt$up,
y0 = 1:nrow(dt), lend = 1,
col = col, lwd = 4)
legend("topleft",
legend = c(eval(substitute( expression(paste(mu," = ",37)))),
sprintf("qnorm CI: [%.f, %.f]",QNORM[1], QNORM[2]),
sprintf("bootstrap CI: [%.f, %.f]",BOOT[1], BOOT[2]),
sprintf("t CI: [%.f, %.f]",TPROCEDURE[1], TPROCEDURE[2])),
lty = c(1,1,1,1),
col = c("black",col), lwd = 4)
}
# example of how to use the function:
compare_CI(ybar = 36, QNORM = c(25,40), BOOT = c(31, 38), TPROCEDURE = c(28, 40))
compare_CI <- function(ybar, QNORM, BOOT, TPROCEDURE,
col = c("#E41A1C","#377EB8","#4DAF4A")) {
dt <- data.frame(type = c("qnorm", "bootstrap", "t"),
ybar = rep(ybar, 3),
low = c(QNORM[1], BOOT[1], TPROCEDURE[1]),
up = c(QNORM[2], BOOT[2], TPROCEDURE[2])
)
plot(dt$ybar, 1:nrow(dt), pch = 20, ylim = c(0, 5),
xlim = range(pretty(c(dt$low, dt$up))),
xlab = "Depth of ocean (m)", ylab = "Confidence Interval Type",
las = 1, cex.axis = 0.8, cex = 3)
abline(v = 37, lty = 2, col = "black", lwd = 2)
segments(x0 = dt$low, x1 = dt$up,
y0 = 1:nrow(dt), lend = 1,
col = col, lwd = 4)
legend("topleft",
legend = c(eval(substitute( expression(paste(mu," = ",37)))),
sprintf("qnorm CI: [%.f, %.f]",QNORM[1], QNORM[2]),
sprintf("bootstrap CI: [%.f, %.f]",BOOT[1], BOOT[2]),
sprintf("t CI: [%.f, %.f]",TPROCEDURE[1], TPROCEDURE[2])),
lty = c(1,1,1,1),
col = c("black",col), lwd = 4)
}
# example of how to use the function:
compare_CI(ybar = 36, QNORM = c(25,40), BOOT = c(31, 38), TPROCEDURE = c(28, 40))
# a markdown link in the first row first column will cause an error for compiling
# pdf
knitr::kable(as.data.frame(rbind(
c("1","[Setting up the computing environment](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a1/a1-setup.pdf)","--","--","September 20, 2018"),
c("2","[Histograms, Means, Medians, Boxplots, Standard Deviation](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a2/a2-hist-mean-median.pdf)",
"[a2_template.Rmd](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a2/a2_template.Rmd)","[[1. 1911 Census of Dublin, Ireland]](https://github.com/sahirbhatnagar/EPIB607/raw/master/data/age_sex_frequencies_ireland.csv)
[[2. Bone mineral loss]](https://github.com/sahirbhatnagar/EPIB607/raw/master/data/boneloss.csv)
[[3. Cancer rate 1930-2014, Males]](https://github.com/sahirbhatnagar/EPIB607/raw/master/data/age-adjusted-cancer-death-rates-males-1930-2014.xlsx)
[[4. Cancer rate 1930-2014, Females]](https://github.com/sahirbhatnagar/EPIB607/raw/master/data/age-adjusted-cancer-death-rates-females-1930-2014.xlsx) ","September 21, 2018"),
c("3","[Sampling Distributions](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a3/a3-sampling-dist.pdf)",
"[a3_template.Rmd](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a3/a3_template.Rmd)","","September 28, 2018"),
c("4","[CLT, Confidence Intervals and Bootstrap](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a4/a4_clt_ci.pdf)",
"[a4_template.Rmd](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a4/a4_template.Rmd)","","October 5, 2018"),
c("5","[Inference for one sample mean](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a5/a5_ttest.pdf)","[a5_template.Rmd](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a5/a5_template.Rmd)","[[1. Weight gain]](https://github.com/sahirbhatnagar/EPIB607/raw/master/data/weightgain.csv) [[2. Full moon]](https://github.com/sahirbhatnagar/EPIB607/raw/master/data/fullmoon.csv)","October 14, 2018"),
c("6","Tests of Significance and p-values","","","October 19, 2018"),
c("7","One-Sample Inference","","","November 2, 2018"),
c("8","Two-Sample Inference","","","November 9, 2018"),
c("9","Regression","","","November 16, 2018"),
c("10","Nonparametric Statistics","","","November 23, 2018")
)),
col.names = c("Assignment","Topic","Template","Data","Due"),
booktabs = TRUE)
DT <- xlsx::read.xlsx("~/Downloads/AlphaBRCA-Density-Kappa.xlsx")
DT <- xlsx::read.xlsx("~/Downloads/AlphaBRCA-Density-Kappa.xlsx", sheetIndex = 1)
DT
View(DT)
DT <- DT[!is.na(DT$AI),]
DT
data(diagnoses)
pacman::p_load(irr)
data(diagnoses)
head(diagnoses)
str(diagnoses)
str(DT)
levels(DT$AI)
head(DT)
data(diagnoses)
head(diagnoses)
kappam.fleiss(DT) # Fleiss' Kappa
kappam.fleiss(DT, detail = T) # Fleiss' Kappa
colnames(DT)
kappam.fleiss(DT[,c("AI","GOLD")], detail = T) # Fleiss' Kappa
kappam.light(DT[,c("AI","GOLD")], detail = T) # Fleiss' Kappa
kappam.light(DT[,c("AI","GOLD")]) # Fleiss' Kappa
kappam.fleiss(DT[,c("AI","GOLD")], detail = T) # Fleiss' Kappa
data(anxiety)
kendall(anxiety, TRUE)
head(anxiety)
kendall(DT[,c("AI","GOLD")])
kendall(DT[,c("AI","GOLD")], correct = T)
head(DT)
dput(colnames(DT))
kendall(DT[,c("KELLOW", "THERIAULT", "ZHANG")], correct = T)
kendall(DT[,c("GOLD","KELLOW", "THERIAULT", "ZHANG")], correct = T)
kendall(DT[,c("AI","GOLD")], correct = T)
# AI and GOLD
kendall(DT[,c("AI","GOLD")], correct = T)
kendall(DT[,c("GOLD","KELLOW", "THERIAULT", "ZHANG")], correct = T)
# GOLD and 3 raters
kendall(DT[,c("GOLD","KELLOW", "THERIAULT", "ZHANG")], correct = T)
# 3 Raters only
kendall(DT[,c("KELLOW", "THERIAULT", "ZHANG")], correct = T)
# AI and GOLD
res <- kendall(DT[,c("AI","GOLD")], correct = T)
res$statistic
res$method
res$irr.name
res$value
res$p.value
pacman::p_load(vegan)
data(mite)
mite
mite.hel <- decostand(mite, "hel")
mite.hel
# Reproduce the results shown in Table 2 of Legendre (2005), a single group
mite.small <- mite.hel[c(4,9,14,22,31,34,45,53,61,69),c(13:15,23)]
kendall.global(mite.small)
kendall.post(mite.small, mult="holm")
kendall.global(DT)
kendall.global(DT[,c("AI","GOLD")])
.58*100000
.58*100000/100
# Confidence Interval using t procedure
#t score function
qt_ls <- function(p, df, mean, sd) qt(p = p, df = df) * sd + mean
n = 201
food_store_ybar <- 18.67
food_store_SE <- 24.95/sqrt(n)
food_store_CI <- qt_ls(p = c(0.025,0.975), df = n-1, mean = food_store_ybar, sd = food_store_SE)
food_store_CI <- round(food_store_CI, 2)
mass_merch_ybar <- 32.38
mass_merch_SE <- 33.37/sqrt(n)
mass_merch_CI <- qt_ls(p = c(0.025,0.975), df = n-1, mean = mass_merch_ybar, sd = mass_merch_SE)
mass_merch_CI <- round(mass_merch_CI, 2)
pharmacy_ybar <- 48.6
pharmacy_SE <- 35.62/sqrt(n)
pharmacy_CI <- qt_ls(p = c(0.025,0.975), df = n-1, mean = pharmacy_ybar, sd = pharmacy_SE)
pharmacy_CI
pharmacy_CI <- pharmacy_ybar + qt(p = c(0.025,0.975), df = n-1) * pharmacy_SE
pharmacy_CI
source("https://github.com/sahirbhatnagar/EPIB607/raw/master/exercises/water/automate_water_task.R")
index.n.20 <- c(2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,
2066,2067,2068,2069,2070,2071,2072,2073,2074,2075)
depths.n.20 <- automate_water_task(index = index.n.20, student_id = 260676245, type = "depth")
depths.n.20$alt = round(depths.n.20$alt/100,0)
