sprintf("= %0.2f (i.e. %0.2f)",means[2]/means[1],
means[2]/means[1]-1)))
# create boxplots
boxplot(alt ~ South, data = depths,
ylab="Ocean Depth (metres)",
xlab="NORTH                                                                       SOUTH",
pch=19,cex=0.25)
points(c(1,2), means, pch=19)
text(0.9, means[1],
expression(widehat(mu[0])) )
text(2.1, means[2],
expression(widehat(mu[1])) )
segments(1,means[1],2,means[1],
lty="dotted")
segments(1,means[1],2,means[2],
lty="dotted")
segments(2.2,means[1],2.45,means[1],
lty="dotted")
segments(2.2,means[2],2.45,means[2],
lty="dotted")
text((2.2+2.45)/2,means[2],
sprintf("+ %0.2f m", means[2]-means[1]), adj=c(0.5,-0.25),cex=0.75)
text(2.5,means[1],
expression(hat(Delta)),adj=c(0.5,0))
arrows(0.8,means[1],0.43,means[1],
length=0.05,angle=20)
arrows(0.8,means[2],0.43,means[2],
length=0.05,angle=20)
# load function to get depths
source("https://github.com/sahirbhatnagar/EPIB607/raw/master/exercises/water/automate_water_task.R")
# get 1000 depths
set.seed(222333444)
depths <- automate_water_task(index = sample(1:50000, 1000),
student_id = 222333444, type = "depth")
# separate by north and south hemisphere
depths_north <- depths[which(depths$lat>0),]
depths_south <- depths[which(depths$lat<0),]
# restrict sample to 200 (at random)
depths_north <- depths_north[sample(1:nrow(depths_north), 200), ]
depths_south <- depths_south[sample(1:nrow(depths_south), 200), ]
# add indicator variable
depths_north$South <- 0
depths_south$South <- 1
# combine data
depths <- rbind(depths_north, depths_south)
head(depths)
# calculate means by hemisphere
means <- aggregate(x = depths, by = list(depths$South), FUN = "mean")$alt
# create boxplot and annotate plot
boxplot(alt ~ South, data = depths,
ylab="Ocean Depth (metres)",
xlab="NORTH                                                                       SOUTH",
pch=19,cex=0.25)
points(c(1,2), means, pch=19)
text(0.9, means[1],
expression(widehat(mu[0])) )
text(2.1, means[2],
expression(widehat(mu[1])) )
segments(1,means[1],2,means[1],
lty="dotted")
segments(1,means[1],2,means[2],
lty="dotted")
segments(2.2,means[1],2.45,means[1],
lty="dotted")
segments(2.2,means[2],2.45,means[2],
lty="dotted")
text((2.2+2.45)/2,means[2],
sprintf("+ %0.2f m", means[2]-means[1]), adj=c(0.5,-0.25),cex=0.75)
text(2.5,means[1],
expression(hat(Delta)),adj=c(0.5,0))
arrows(0.8,means[1],0.43,means[1],
length=0.05,angle=20)
arrows(0.8,means[2],0.43,means[2],
length=0.05,angle=20)
# t.test
t.test(alt ~ South, data = depths)
# regression
fit <- lm(alt ~ South, data = depths)
summary(fit)
confint(fit)
sds <- aggregate(x = depths, by = list(depths$South), FUN = "sd")$alt
sds
qnorm(c(0.025, 0.975), mean = means[2], sd = sds / sqrt(nrow(depths_south)))
means[2]
qnorm(c(0.025, 0.975), mean = means[2], sd = sds[2] / sqrt(nrow(depths_south)))
sds[2] / sqrt(nrow(depths_south))
vcov(fit)
sqrt(24826.73)
# t.test
t.test(alt ~ South, data = depths, var.equal = TRUE)
t.test(alt ~ South, data = depths, var.equal = FALSE)
sd(c(depths_north$alt, depths_south$alt))
sd(c(depths_north$alt, depths_south$alt)) / sqrt(400)
sd(c(depths_north$alt, depths_south$alt)) * sqrt(1/200  + 1/200)
1/200  + 1/200
sqrt(var(depths_north$alt)/nrow(depths_north) +
var(depths_south$alt) / nrow(depths_north))
var0 <- var(depths_north$alt)
var1 <- var(depths_south$alt)
var_pooled <- ((n0-1) * var0 + (n1-1) * var1) / (n0 + n1 - 2)
n0 <- nrow(depths_north)
n1 <- nrow(depths_south)
var0 <- var(depths_north$alt)
var1 <- var(depths_south$alt)
var_pooled <- ((n0-1) * var0 + (n1-1) * var1) / (n0 + n1 - 2)
var_pooled
sqrt(var_pooled)
# t.test
t.test(alt ~ South, data = depths, var.equal = FALSE) # default
sqrt(var0/n0 + var1/n1)
# t.test
t.test(alt ~ South, data = depths, var.equal = FALSE) # default
sqrt(var0/n0 + var1/n1)
mean0 <- mean(depths_north$alt)
mean1 <- mean(depths_south$alt)
n0 <- nrow(depths_north)
n1 <- nrow(depths_south)
mean0 <- mean(depths_north$alt)
mean1 <- mean(depths_south$alt)
var0 <- var(depths_north$alt)
var1 <- var(depths_south$alt)
var_pooled <- ((n0-1) * var0 + (n1-1) * var1) / (n0 + n1 - 2)
# t.test
t.test(alt ~ South, data = depths, var.equal = FALSE) # default
qnorm(c(0.025, 0.975), mean = mean1 - mean0, sd = sqrt(var0/n0 + var1/n1))
qnorm(c(0.025, 0.975), mean = mean0 - mean1, sd = sqrt(var0/n0 + var1/n1))
qt(c(0.025, 0.975), df = 349.62)
qt(c(0.025, 0.975), df = 349.62) * sqrt(var0/n0 + var1/n1) + (mean0 - mean1)
# equal variances
t.test(alt ~ South, data = depths, var.equal = TRUE)
sd(c(depths_north$alt, depths_south$alt)) * sqrt(1/200 + 1/200)
SEM_unequal_variances <- sqrt(var0/n0 + var1/n1)
SEM_equal_variances <- sqrt(var_pooled * (1/n0 + 1/n1))
# t.test
# unequal variances
t.test(alt ~ South, data = depths, var.equal = FALSE) # default
qnorm(c(0.025, 0.975), mean = mean0 - mean1, sd = )
qt(c(0.025, 0.975), df = 349.62) * sqrt(var0/n0 + var1/n1) + (mean0 - mean1)
var0 <- var(depths_north$alt)
var1 <- var(depths_south$alt)
var_pooled <- ((n0-1) * var0 + (n1-1) * var1) / (n0 + n1 - 2)
SEM_unequal_variances <- sqrt(var0/n0 + var1/n1)
SEM_equal_variances <- sqrt(var_pooled * (1/n0 + 1/n1))
SEM_unequal_variances
SEM_equal_variances
SEM_unequal_variances <- sqrt(var0/n0 + var1/n1)
SEM_equal_variances <- sqrt(var_pooled * (1/n0 + 1/n1))
SEM_equal_variances
SEM_unequal_variances
# inference
n0 <- nrow(depths_north)
n1 <- nrow(depths_south)
mean0 <- mean(depths_north$alt)
mean1 <- mean(depths_south$alt)
var0 <- var(depths_north$alt)
var1 <- var(depths_south$alt)
var_pooled <- ((n0-1) * var0 + (n1-1) * var1) / (n0 + n1 - 2)
var_pooled
var(c(depths_north$alt, depths_south$alt))
sqrt(var0/n0 + var1/n1)
options(digits = 10)
SEM_unequal_variances
SEM_equal_variances
qnorm(c(0.025, 0.975), mean = mean0 - mean1, sd = SEM_unequal_variances)
qt(c(0.025, 0.975), df = 349.62) * SEM_unequal_variances + (mean0 - mean1)
# t.test
# unequal variances
t.test(alt ~ South, data = depths, var.equal = FALSE) # default
qt(c(0.025, 0.975), df = 349.62) * SEM_unequal_variances + (mean0 - mean1)
# equal variances
t.test(alt ~ South, data = depths, var.equal = TRUE)
qnorm(c(0.025, 0.975), mean = mean0 - mean1, sd = SEM_equal_variances)
var0 <- var(depths_north$alt)
var1 <- var(depths_south$alt)
var_pooled <- ((n0-1) * var0 + (n1-1) * var1) / (n0 + n1 - 2)
var(c(depths_north$alt, depths_south$alt))
SEM_unequal_variances <- sqrt(var0/n0 + var1/n1)
SEM_equal_variances <- sqrt(var_pooled * (1/n0 + 1/n1))
# t.test
# unequal variances
t.test(alt ~ South, data = depths, var.equal = FALSE) # default
qnorm(c(0.025, 0.975), mean = mean0 - mean1, sd = SEM_unequal_variances)
qt(c(0.025, 0.975), df = 349.62) * SEM_unequal_variances + (mean0 - mean1)
# equal variances
t.test(alt ~ South, data = depths, var.equal = TRUE)
qnorm(c(0.025, 0.975), mean = mean0 - mean1, sd = SEM_equal_variances)
qt(c(0.025, 0.975), df = 398) * SEM_equal_variances + (mean0 - mean1)
var0
var1
var(c(depths_north$alt, depths_south$alt))
sd(c(depths_north$alt, depths_south$alt)) * sqrt(1/n0 + 1/n1)
qt(c(0.025, 0.975), df = 398) * sd(c(depths_north$alt, depths_south$alt)) * sqrt(1/n0 + 1/n1) + (mean0 - mean1)
# equal variances
t.test(alt ~ South, data = depths, var.equal = TRUE)
qt(c(0.025, 0.975), df = 398) * sd(c(depths_north$alt, depths_south$alt)) * sqrt(1/n0 + 1/n1) + (mean0 - mean1)
qt(c(0.025, 0.975), df = 398) * SEM_equal_variances + (mean0 - mean1)
# equal variances
t.test(alt ~ South, data = depths, var.equal = TRUE)
qt(c(0.025, 0.975), df = 398) * SEM_equal_variances + (mean0 - mean1)
SEM_unequal_variances <- sqrt(var0/n0 + var1/n1)
SEM_unequal_variances
var0 <- var(depths_north$alt)
var1 <- var(depths_south$alt)
# inference
n0 <- nrow(depths_north)
n1 <- nrow(depths_south)
mean0 <- mean(depths_north$alt)
mean1 <- mean(depths_south$alt)
var0 <- var(depths_north$alt)
var1 <- var(depths_south$alt)
SEM <- sqrt(var0/n0 + var1/n1)
# t.test
# unequal variances
t.test(alt ~ South, data = depths, var.equal = FALSE) # default
qnorm(c(0.025, 0.975), mean = mean0 - mean1, sd = SEM_unequal_variances)
qt(c(0.025, 0.975), df = 349.62) * SEM_unequal_variances + (mean0 - mean1)
# t.test
# unequal variances
t.test(alt ~ South, data = depths, var.equal = FALSE) # default
qnorm(c(0.025, 0.975), mean = mean0 - mean1, sd = SEM)
qt(c(0.025, 0.975), df = 349.62) * SEM + (mean0 - mean1)
qt(c(0.025, 0.975), df = 349.61783) * SEM + (mean0 - mean1)
qt(c(0.025, 0.975), df = n0 + n1 - 2) * SEM + (mean0 - mean1)
# equal variances
t.test(alt ~ South, data = depths, var.equal = TRUE)
qnorm(c(0.025, 0.975), mean = mean0 - mean1, sd = SEM)
qt(c(0.025, 0.975), df = n0 + n1 - 2) * SEM + (mean0 - mean1)
# regression
fit <- lm(alt ~ South, data = depths)
summary(fit)
test_statistic <- (mean0 - mean1) / SEM
test_statistic
# regression
fit <- lm(alt ~ South, data = depths)
SEM
summary(fit)
confint(fit)
# equal variances
t.test(alt ~ South, data = depths, var.equal = TRUE)
# lm assumes equal variances
qt(c(0.025, 0.975), df = n0 + n1 - 2) * SEM + (mean0 - mean1)
SEM
source("https://github.com/sahirbhatnagar/EPIB607/raw/master/exercises/water/automate_water_task.R")
# get 1000 depths
set.seed(222333444)
depths <- automate_water_task(index = sample(1:50000, 1000),
student_id = 222333444, type = "depth")
# separate by north and south hemisphere
depths_north <- depths[which(depths$lat>0),]
depths_south <- depths[which(depths$lat<0),]
# restrict sample to 200 (at random)
depths_north <- depths_north[sample(1:nrow(depths_north), 200), ]
depths_south <- depths_south[sample(1:nrow(depths_south), 200), ]
# add indicator variable
depths_north$South <- 0
depths_south$South <- 1
# combine data
depths <- rbind(depths_north, depths_south)
head(depths)
# calculate mean and sd by hemisphere
means <- aggregate(x = depths, by = list(depths$South), FUN = "mean")$alt
sds <- aggregate(x = depths, by = list(depths$South), FUN = "sd")$alt
# create boxplot and annotate plot
boxplot(alt ~ South, data = depths,
ylab="Ocean Depth (metres)",
xlab="NORTH                                                                       SOUTH",
pch=19,cex=0.25)
points(c(1,2), means, pch=19)
text(0.9, means[1],
expression(widehat(y[0])) )
text(2.1, means[2],
expression(widehat(y[1])) )
segments(1,means[1],2,means[1],
lty="dotted")
segments(1,means[1],2,means[2],
lty="dotted")
segments(2.2,means[1],2.45,means[1],
lty="dotted")
segments(2.2,means[2],2.45,means[2],
lty="dotted")
text((2.2+2.45)/2,means[2],
sprintf("+ %0.2f m", means[2]-means[1]), adj=c(0.5,-0.25),cex=0.75)
text(2.5,means[1],
expression(hat(Delta)),adj=c(0.5,0))
arrows(0.8,means[1],0.43,means[1],
length=0.05,angle=20)
arrows(0.8,means[2],0.43,means[2],
length=0.05,angle=20)
plot(dpois(0:6, lambda = 0.61), type = "h")
plot(0:6, dpois(0:6, lambda = 0.61), type = "h")
dpois(0:6, lambda = 0.61)
# load function to get depths
source("https://github.com/sahirbhatnagar/EPIB607/raw/master/exercises/water/automate_water_task.R")
# get 1000 depths
set.seed(222333444)
depths <- automate_water_task(index = sample(1:50000, 1000),
student_id = 222333444, type = "depth")
head(depths)
# separate by north and south hemisphere
depths_north <- depths[which(depths$lat>0),]
depths_south <- depths[which(depths$lat<0),]
which(depths$lat>0)
# separate by north and south hemisphere
depths_north <- depths[which(depths$lat>0),]
depths_south <- depths[which(depths$lat<0),]
# restrict sample to 200 (at random)
depths_north <- depths_north[sample(1:nrow(depths_north), 200), ]
depths_south <- depths_south[sample(1:nrow(depths_south), 200), ]
dim(depths_north)
dim(depths_south)
# add indicator variable
depths_north$South <- 0
depths_south$South <- 1
# combine data
depths <- rbind(depths_north, depths_south)
head(depths)
# calculate mean and sd by hemisphere
means <- aggregate(x = depths, by = list(depths$South), FUN = "mean")$alt
means
source("https://github.com/sahirbhatnagar/EPIB607/raw/master/exercises/water/automate_water_task.R")
# get 1000 depths
set.seed(222333444)
depths <- automate_water_task(index = sample(1:50000, 1000),
student_id = 222333444, type = "depth")
head(depths)
# separate by north and south hemisphere
depths_north <- depths[which(depths$lat>0),]
depths_south <- depths[which(depths$lat<0),]
# restrict sample to 200 (at random)
depths_north <- depths_north[sample(1:nrow(depths_north), 200), ]
depths_south <- depths_south[sample(1:nrow(depths_south), 200), ]
dim(depths_north)
dim(depths_south)
# add indicator variable
depths_north$South <- 0
depths_south$South <- 1
# combine data
depths <- rbind(depths_north, depths_south)
head(depths)
# calculate mean and sd by hemisphere
means <- aggregate(x = depths, by = list(depths$South), FUN = "mean")$alt
sds <- aggregate(x = depths, by = list(depths$South), FUN = "sd")$alt
table(depths$South)
fit <- lm(alt ~ South, data = depths)
summary(fit)
plot(alt ~ South, data = depths)
ggformula::gf_point(alt ~ South, data = depths)
ggformula::gf_jitter(alt ~ South, data = depths)
ggformula::gf_jitter(alt ~ South, data = depths, width = 0.1)
ggformula::gf_jitter(alt ~ South, data = depths, width = 0.05)
library(cowplot)
ggformula::gf_jitter(alt ~ South, data = depths, width = 0.05)
theme_set(theme_cowplot())
library(ggplot2)
theme_set(theme_cowplot())
ggformula::gf_jitter(alt ~ South, data = depths, width = 0.05)
exp(0.02196)
(3643.08+80.88)/(3643.08)
drinks <- read.csv("/home/sahir/git_repositories/epib607/slides/regression/handouts/drinks.csv")
str(drinks)
ggformula::gf_jitter(drinks ~ gender, data = drinks)
fit <- lm(drinks ~ gender, data = drinks)
summary(fit)
fit <- glm(drinks ~ gender, data = drinks, family = gaussian(link=log))
summary(fit)
# load function to get depths
source("https://github.com/sahirbhatnagar/EPIB607/raw/master/exercises/water/automate_water_task.R")
# get 1000 depths
set.seed(222333444)
depths <- automate_water_task(index = sample(1:50000, 1000),
student_id = 222333444, type = "depth")
# separate by north and south hemisphere
depths_north <- depths[which(depths$lat>0),]
depths_south <- depths[which(depths$lat<0),]
# restrict sample to 200 (at random)
depths_north <- depths_north[sample(1:nrow(depths_north), 200), ]
depths_south <- depths_south[sample(1:nrow(depths_south), 200), ]
# add indicator variable
depths_north$South <- 0
depths_south$South <- 1
# combine data
depths <- rbind(depths_north, depths_south)
head(depths)
# calculate mean and sd by hemisphere
means <- aggregate(x = depths, by = list(depths$South), FUN = "mean")$alt
sds <- aggregate(x = depths, by = list(depths$South), FUN = "sd")$alt
# create boxplot and annotate plot
boxplot(alt ~ South, data = depths,
ylab="Ocean Depth (metres)",
xlab="NORTH                                                                       SOUTH",
pch=19,cex=0.25)
points(c(1,2), means, pch=19)
text(0.9, means[1],
expression(widehat(mu[0])) )
text(2.1, means[2],
expression(widehat(mu[1])) )
segments(1,means[1],2,means[1],
lty="dotted")
segments(1,means[1],2,means[2],
lty="dotted")
segments(2.2,means[1],2.45,means[1],
lty="dotted")
segments(2.2,means[2],2.45,means[2],
lty="dotted")
text((2.2+2.45)/2,means[2],
sprintf("+ %0.2f m", means[2]-means[1]), adj=c(0.5,-0.25),cex=0.75)
text(2.5,means[1],
expression(hat(Delta)),adj=c(0.5,0))
arrows(0.8,means[1],0.43,means[1],
length=0.05,angle=20)
arrows(0.8,means[2],0.43,means[2],
length=0.05,angle=20)
# inference
n0 <- nrow(depths_north)
n1 <- nrow(depths_south)
mean0 <- mean(depths_north$alt)
mean1 <- mean(depths_south$alt)
var0 <- var(depths_north$alt)
var1 <- var(depths_south$alt)
SEM <- sqrt(var0/n0 + var1/n1)
test_statistic <- (mean0 - mean1) / SEM
# t.test
# unequal variances
t.test(alt ~ South, data = depths, var.equal = FALSE) # default
qt(c(0.025, 0.975), df = 349.61783) * SEM + (mean0 - mean1)
qnorm(c(0.025, 0.975), mean = mean0 - mean1, sd = SEM)
# equal variances
t.test(alt ~ South, data = depths, var.equal = TRUE)
qt(c(0.025, 0.975), df = n0 + n1 - 2) * SEM + (mean0 - mean1)
qnorm(c(0.025, 0.975), mean = mean0 - mean1, sd = SEM)
fit <- lm(alt ~ 1, data = depths)
summary(fit)
mean(depths$alt)
sd(depths$alt) / sqrt(nrow(depths))
mean(depths$alt)/ (sd(depths$alt) / sqrt(nrow(depths)))
mean((mean(depths$alt)-depths$alt)^2)
sqrt(mean((mean(depths$alt)-depths$alt)^2))
sqrt((mean(depths$alt)-depths$alt)^2/(nrow(depths)-1))
sqrt(sum(mean(depths$alt)-depths$alt)^2/(nrow(depths)-1))
sqrt(sum((mean(depths$alt)-depths$alt)^2/(nrow(depths)-1)))
pt(46.8, 399, lower.tail = F)
sd(depths$alt)
3643.08+80.88
var0
sqrt(var0)/sqrt(200)
mean0
sqrt(var0)/sqrt(400)
mean(depths$South)
(depths$South-0.5)^2
(1576)^2* (1/400 + 0.5^2/sum((depths$South-0.5)^2))
varb0 <- (1576)^2* (1/400 + 0.5^2/sum((depths$South-0.5)^2))
sqrt(varb0)
pt(0.513, 398, lower.tail = F)
pt(0.513, 398, lower.tail = F)*2
sd(depths$alt)
var0 <- var(depths_north$alt)
var1 <- var(depths_south$alt)
var0
var1
var(depths$alt)
sum((depths$alt-mean(depths$alt))^2)
sum((depths$alt-mean(depths$alt))^2) / 398
sqrt(sum((depths$alt-mean(depths$alt))^2) / 398)
# regression
fit <- lm(alt ~ South, data = depths)
summary(fit)
sqrt(sum((depths$alt-mean(depths$alt))^2) / 398)
sqrt(sum((depths$alt-predict(fit))^2) / 398)
predict(fit)
sum((depths$alt-predict(fit))^2) / 398
sum((depths$alt-mean(depths$alt))^2) / 398
sqrt(sum((depths$alt-mean(depths$alt))^2) / 398)
sqrt(sum((depths$alt-predict(fit))^2) / 398)
fit$residuals
sum(fit$residuals^2)
sum(fit$residuals^2)/398
sqrt(sum((depths$alt-predict(fit))^2) / 398)
sum((depths$alt-predict(fit))^2) / 398
sum(fit$residuals^2)/398
sqrt(sum(fit$residuals^2)/398)
fit$df.residual
library(broom)
tidy(fit)
tt <- tidy(fit)
tt$std.error
augment(fit)
sqrt(sum((depths$alt-mean(depths$alt))^2) / 398)
sum((depths$alt-predict(fit))^2) / 398
sqrt(sum(fit$residuals^2)/398)
head(iris)
fit <- lm(Sepal.Length ~ ., data = iris)
summary(FIT)
summary(fit)
fit$df.residual
sqrt(sum(fit$residuals^2)/fit$df.residual)
sqrt(sum((iris$Sepal.Length-mean(iris$Sepal.Length))^2) / fit$df.residual)
fit$df.residual
exp(8.20058)
exp(0.02196)
0.03823/0.04517
sqrt(988758010)
sqrt(988758010/399)
sqrt(988103771/399)
sqrt(988103771/398)
0.02196+qt(c(0.025,0.975))*0.04278
0.02196+qt(c(0.025,0.975), 398)*0.04278
tt <- 0.02196+qt(c(0.025,0.975), 398)*0.04278
exp(tt)
988103771/398
sqrt(988103771/398)
sqrt(988103771/399)
sqrt(988758010/399)
