legend = c(expression(mu "=37"),
sprintf("plus/minus CI: [%.f, %.f]",PM[1], PM[2]),
sprintf("qnorm CI: [%.f, %.f]",QNORM[1], QNORM[2]),
sprintf("bootstrap CI: [%.f, %.f]",BOOT[1], BOOT[2])),
lty = c(1, 1,1,1),
col = c("black",col), lwd = 4)
}
compare_CI <- function(ybar, PM, QNORM, BOOT,
col = c("#E41A1C","#377EB8","#4DAF4A")) {
dt <- data.frame(type = c("plus_minus", "qnorm", "bootstrap"),
ybar = rep(ybar, 3),
low = c(PM[1], QNORM[1], BOOT[1]),
up = c(PM[2], QNORM[2], BOOT[2])
)
plot(dt$ybar, 1:nrow(dt), pch = 20, ylim = c(0, 5),
xlim = range(pretty(c(dt$low, dt$up))),
xlab = 'Depth of ocean (m)', ylab = 'Confidence Interval Type',
las = 1, cex.axis = 0.8, cex = 3)
abline(v = 37, lty = 2, col = "black", lwd = 2)
segments(x0 = dt$low, x1 = dt$up,
y0 = 1:nrow(dt), lend = 1,
col = col, lwd = 4)
legend("topleft",
legend = c(expression(*mu* "=37"),
sprintf("plus/minus CI: [%.f, %.f]",PM[1], PM[2]),
sprintf("qnorm CI: [%.f, %.f]",QNORM[1], QNORM[2]),
sprintf("bootstrap CI: [%.f, %.f]",BOOT[1], BOOT[2])),
lty = c(1, 1,1,1),
col = c("black",col), lwd = 4)
}
latex2exp::TeX("$\\mu=37$")
compare_CI <- function(ybar, PM, QNORM, BOOT,
col = c("#E41A1C","#377EB8","#4DAF4A")) {
dt <- data.frame(type = c("plus_minus", "qnorm", "bootstrap"),
ybar = rep(ybar, 3),
low = c(PM[1], QNORM[1], BOOT[1]),
up = c(PM[2], QNORM[2], BOOT[2])
)
plot(dt$ybar, 1:nrow(dt), pch = 20, ylim = c(0, 5),
xlim = range(pretty(c(dt$low, dt$up))),
xlab = 'Depth of ocean (m)', ylab = 'Confidence Interval Type',
las = 1, cex.axis = 0.8, cex = 3)
abline(v = 37, lty = 2, col = "black", lwd = 2)
segments(x0 = dt$low, x1 = dt$up,
y0 = 1:nrow(dt), lend = 1,
col = col, lwd = 4)
legend("topleft",
legend = c(expression(`$\mu=37$` = paste("", "", mu = 37, , , , "")),
sprintf("plus/minus CI: [%.f, %.f]",PM[1], PM[2]),
sprintf("qnorm CI: [%.f, %.f]",QNORM[1], QNORM[2]),
sprintf("bootstrap CI: [%.f, %.f]",BOOT[1], BOOT[2])),
lty = c(1, 1,1,1),
col = c("black",col), lwd = 4)
}
latex2exp::TeX("$\mu=37$")
latex2exp::TeX("$\\mu=37$")
compare_CI <- function(ybar, PM, QNORM, BOOT,
col = c("#E41A1C","#377EB8","#4DAF4A")) {
dt <- data.frame(type = c("plus_minus", "qnorm", "bootstrap"),
ybar = rep(ybar, 3),
low = c(PM[1], QNORM[1], BOOT[1]),
up = c(PM[2], QNORM[2], BOOT[2])
)
plot(dt$ybar, 1:nrow(dt), pch = 20, ylim = c(0, 5),
xlim = range(pretty(c(dt$low, dt$up))),
xlab = 'Depth of ocean (m)', ylab = 'Confidence Interval Type',
las = 1, cex.axis = 0.8, cex = 3)
abline(v = 37, lty = 2, col = "black", lwd = 2)
segments(x0 = dt$low, x1 = dt$up,
y0 = 1:nrow(dt), lend = 1,
col = col, lwd = 4)
legend("topleft",
legend = c(eval(substitute( expression(paste(mu,"=",37)))),
sprintf("plus/minus CI: [%.f, %.f]",PM[1], PM[2]),
sprintf("qnorm CI: [%.f, %.f]",QNORM[1], QNORM[2]),
sprintf("bootstrap CI: [%.f, %.f]",BOOT[1], BOOT[2])),
lty = c(1, 1,1,1),
col = c("black",col), lwd = 4)
}
# example of how to use the function:
compare_CI(ybar = 36, PM = c(28, 40), QNORM = c(25,40), BOOT = c(31, 38))
compare_CI <- function(ybar, PM, QNORM, BOOT,
col = c("#E41A1C","#377EB8","#4DAF4A")) {
dt <- data.frame(type = c("plus_minus", "qnorm", "bootstrap"),
ybar = rep(ybar, 3),
low = c(PM[1], QNORM[1], BOOT[1]),
up = c(PM[2], QNORM[2], BOOT[2])
)
plot(dt$ybar, 1:nrow(dt), pch = 20, ylim = c(0, 5),
xlim = range(pretty(c(dt$low, dt$up))),
xlab = 'Depth of ocean (m)', ylab = 'Confidence Interval Type',
las = 1, cex.axis = 0.8, cex = 3)
abline(v = 37, lty = 2, col = "black", lwd = 2)
segments(x0 = dt$low, x1 = dt$up,
y0 = 1:nrow(dt), lend = 1,
col = col, lwd = 4)
legend("topleft",
legend = c(eval(substitute( expression(paste(mu," = ",37)))),
sprintf("plus/minus CI: [%.f, %.f]",PM[1], PM[2]),
sprintf("qnorm CI: [%.f, %.f]",QNORM[1], QNORM[2]),
sprintf("bootstrap CI: [%.f, %.f]",BOOT[1], BOOT[2])),
lty = c(1, 1,1,1),
col = c("black",col), lwd = 4)
}
# example of how to use the function:
compare_CI(ybar = 36, PM = c(28, 40), QNORM = c(25,40), BOOT = c(31, 38))
# a markdown link in the first row first column will cause an error for compiling
# pdf
knitr::kable(as.data.frame(rbind(
c("1","[Setting up the computing environment](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a1/a1-setup.pdf)","--","--","September 20, 2018"),
c("2","[Histograms, Means, Medians, Boxplots, Standard Deviation](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a2/a2-hist-mean-median.pdf)",
"[a2_template.Rmd](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a2/a2_template.Rmd)","[[1. 1911 Census of Dublin, Ireland]](https://github.com/sahirbhatnagar/EPIB607/raw/master/data/age_sex_frequencies_ireland.csv)
[[2. Bone mineral loss]](https://github.com/sahirbhatnagar/EPIB607/raw/master/data/boneloss.csv)
[[3. Cancer rate 1930-2014, Males]](https://github.com/sahirbhatnagar/EPIB607/raw/master/data/age-adjusted-cancer-death-rates-males-1930-2014.xlsx)
[[4. Cancer rate 1930-2014, Females]](https://github.com/sahirbhatnagar/EPIB607/raw/master/data/age-adjusted-cancer-death-rates-females-1930-2014.xlsx) ","September 21, 2018"),
c("3","[Sampling Distributions](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a3/a3-sampling-dist.pdf)",
"[a3_template.Rmd](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a3/a3_template.Rmd)","","September 28, 2018"),
c("4","[CLT, Confidence Intervals and Bootstrap](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a4/a4_clt_ci.pdf)",
"[a4_template.Rmd](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a4/a4_template.Rmd)","October 5, 2018"),
c("5","Confidence Intervals","","","October 12, 2018"),
c("6","Tests of Significance and p-values","","","October 19, 2018"),
c("7","One-Sample Inference","","","November 2, 2018"),
c("8","Two-Sample Inference","","","November 9, 2018"),
c("9","Regression","","","November 16, 2018"),
c("10","Nonparametric Statistics","","","November 23, 2018")
)),
col.names = c("Assignment","Topic","Template","Data","Due"),
booktabs = TRUE)
# a markdown link in the first row first column will cause an error for compiling
# pdf
knitr::kable(as.data.frame(rbind(
c("1","[Setting up the computing environment](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a1/a1-setup.pdf)","--","--","September 20, 2018"),
c("2","[Histograms, Means, Medians, Boxplots, Standard Deviation](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a2/a2-hist-mean-median.pdf)",
"[a2_template.Rmd](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a2/a2_template.Rmd)","[[1. 1911 Census of Dublin, Ireland]](https://github.com/sahirbhatnagar/EPIB607/raw/master/data/age_sex_frequencies_ireland.csv)
[[2. Bone mineral loss]](https://github.com/sahirbhatnagar/EPIB607/raw/master/data/boneloss.csv)
[[3. Cancer rate 1930-2014, Males]](https://github.com/sahirbhatnagar/EPIB607/raw/master/data/age-adjusted-cancer-death-rates-males-1930-2014.xlsx)
[[4. Cancer rate 1930-2014, Females]](https://github.com/sahirbhatnagar/EPIB607/raw/master/data/age-adjusted-cancer-death-rates-females-1930-2014.xlsx) ","September 21, 2018"),
c("3","[Sampling Distributions](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a3/a3-sampling-dist.pdf)",
"[a3_template.Rmd](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a3/a3_template.Rmd)","","September 28, 2018"),
c("4","[CLT, Confidence Intervals and Bootstrap](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a4/a4_clt_ci.pdf)",
"[a4_template.Rmd](https://github.com/sahirbhatnagar/EPIB607/raw/master/assignments/a4/a4_template.Rmd)","","October 5, 2018"),
c("5","Confidence Intervals","","","October 12, 2018"),
c("6","Tests of Significance and p-values","","","October 19, 2018"),
c("7","One-Sample Inference","","","November 2, 2018"),
c("8","Two-Sample Inference","","","November 9, 2018"),
c("9","Regression","","","November 16, 2018"),
c("10","Nonparametric Statistics","","","November 23, 2018")
)),
col.names = c("Assignment","Topic","Template","Data","Due"),
booktabs = TRUE)
mosaic::xct(p=0.95)
mosaic::xct(p=0.95, df=4)
mosaic::xct(p=0.95, df=10)
mosaic::xct(p=0.97, df=10)
mosaic::xcnorm(p=0.97, df=10)
# function for sampling ocean depths
source("https://github.com/sahirbhatnagar/EPIB607/raw/master/exercises/water/automate_water_task.R")
# from the in-class exercise
index.n.20 <- c(2106,2107,2108,2109,2110,2111,2112,
2113,2114,2115,2116,2117,2118,2119,
2120,2121,2122,2123,2124,2125)
# get depths of ocean sample n=20
depths.n.20 <- automate_water_task(index = index.n.20,
student_id = 260194225, type = "depth")
# change to 100m units
depths.n.20$alt = round(depths.n.20$alt/100,0)
library(mosaic)
# calculate mean depth for your sample
mean_depth <- mean(~ alt, data = depths.n.20)
# 10000 bootstrap samples
s_dist <- do(10000) * mean( ~ alt, data = resample(depths.n.20))
# 95% CI
CI_95 <- quantile(~ mean, data = s_dist, probs = c(0.025, 0.975))
# plot sampling distribution
hist(s_dist$mean, breaks = 50, col = "#56B4E9",
main="",
xlab = "mean depth of the ocean (100m) from each bootstrap sample")
# draw red line at the sample mean
abline(v = mean_depth, lty =1, col = "red", lwd = 4)
# draw black dotted lines at 95% CI
abline(v = CI_95[1], lty =2, col = "black", lwd = 4)
abline(v = CI_95[2], lty =2, col = "black", lwd = 4)
# include legend
library(latex2exp)
legend("topleft",
legend = c(TeX("$\\bar{y} = 36$"),
sprintf("95%% CI: [%.f, %.f]",CI_95[1], CI_95[2])),
lty = c(1,1),
col = c("red","black"), lwd = 4)
df <- as.data.frame(rbind(
c("[1. Live Poll](http://etc.ch/tfZA)"),
c("[2. Bootstrap Confidence Intervals](https://github.com/sahirbhatnagar/EPIB607/raw/master/slides/bootstrap/EPIB607_bootstrap.pdf)"),
c("[3. Bootstrap article in Scientific American](https://www.dropbox.com/s/cxiq70zxxtyxlb5/EfronDiaconisBootstrap.pdf?dl=0)"),
c("[4. Overview Grid](https://www.dropbox.com/s/t7a1bnxdid9y6i3/OverviewGrid.pdf?dl=0)"),
c("[5. Inference about a population mean ($\mu$)](https://github.com/sahirbhatnagar/EPIB607/raw/master/slides/one_sample_mean/EPIB607_one_sample_mean.pdf)")
))
df %>% kable(col.names = NULL) %>%
kable_styling(bootstrap_options = c("striped", "hover"))
df <- as.data.frame(rbind(
c("[1. Live Poll](http://etc.ch/tfZA)"),
c("[2. Bootstrap Confidence Intervals](https://github.com/sahirbhatnagar/EPIB607/raw/master/slides/bootstrap/EPIB607_bootstrap.pdf)"),
c("[3. Bootstrap article in Scientific American](https://www.dropbox.com/s/cxiq70zxxtyxlb5/EfronDiaconisBootstrap.pdf?dl=0)"),
c("[4. Overview Grid](https://www.dropbox.com/s/t7a1bnxdid9y6i3/OverviewGrid.pdf?dl=0)"),
c("[5. Inference about a population mean ($\\mu$)](https://github.com/sahirbhatnagar/EPIB607/raw/master/slides/one_sample_mean/EPIB607_one_sample_mean.pdf)")
))
df %>% kable(col.names = NULL) %>%
kable_styling(bootstrap_options = c("striped", "hover"))
25 + qnorm(c(0.025, 0.975))*1.5
library(mosaic)
mosaic::xct(0.95, df = 5)
mosaic::xqt(p = c(0.025, 0.975), df = 5)
gf_dist("norm", color = "red", kind = "qqstep", resolution = 25) %>%
gf_dist("norm", color = "black", kind = "qq", resolution = 25, size = 2, alpha = 0.5)
ggformula::gf_dist("norm")
ggformula::gf_dist("norm") %>%
gf_dist("t", df = 3)
mosaic::xqt(p = c(0.025, 0.975), df = 5)
xqnorm(p = c(0.025, 0.975)) + ylim(c(-6,6))
xqnorm(p = c(0.025, 0.975), ylim = c(-6,6))
xqnorm(p = c(0.025, 0.975), ylim = c(-6,6), return = "plot")
p1 <- xqnorm(p = c(0.025, 0.975), ylim = c(-6,6), return = "plot")
p1
p1 + ylim(c(-6,6))
, return = "plot"
p1 <- xqnorm(p = c(0.025, 0.975), xlim = c(-6,6))
mosaic::xqt(p = c(0.025, 0.975), df = 5)
qt(0.975, Inf)
qt(0.975, Inf);qnorm(0.975)
mu.m=-0.540
sigma=0.008
n=5
SEM = sigma/sqrt(n)
crit.value = mu.m + qnorm(0.95)*SEM
ht=1.2*dnorm(0,0,SEM)
1.645*sigma/sqrt(n)
Green="blue"
fig1= TRUE
if(fig1){
par(mfrow=c(1,1),mar = c(5,0.001,0.001,0.001) )
plot(c(mu.m-4*SEM,mu.m+9*SEM),c(-ht,13*ht),
col="white",xlab="Freezing point (degrees C)")
#abline(v=crit.value)
text(-0.51,3*ht,"Probability (%)
of exceeding cutoff",adj=c(1,0),col="red")
text(-0.555,12*ht,
expression(paste(
mu[Milk],
" = -0.5400; ",
sigma," = 0.0080;")) ,
adj=c(0,0))
text(-0.555,11*ht,
expression(paste(
italic(n),
"=5; SEM = ",
sigma/sqrt(italic(n))," = 0.0036")
),
adj=c(0,0))
text(-0.555,10*ht,"alpha=0.05, 1 sided alternative",
adj=c(0,0))
text(-0.555,9*ht,"qnorm(0.95) : 1.645",
adj=c(0,0), family="mono")
text(-0.555,8*ht,"1.645 * SEM = 0.0059",adj=c(0,0))
segments(crit.value,-0.4*ht,
crit.value,13*ht,col="red",
lwd=1,lty="dotted")
text(-0.555,7.0*ht,
expression(paste(
"cutoff = ",
mu[Milk],
" + 1.645*SEM.")),
adj=c(0,0.5),cex=0.95)
text(-0.555,-0.25*ht,
"cutoff = -0.5400 + 0.0059 = -0.5341",
adj=c(0,0.5),cex=0.65)
arrows(-0.540,-0.25*ht, crit.value,-0.25*ht,
length=0.05, angle=20,col=Green)
I=0
for ( pct.w in seq(0,3,0.25) ){
mu = mu.m*(100-pct.w)/100
if(pct.w==3) text(-0.52,-ht/1.3,"Added Water",
cex=0.75, adj=c(0,0.5))
green= seq(mu-3*SEM,crit.value,length.out=50)
d = c(dnorm(green,mu,SEM),0)
polygon(c(green,crit.value),d + I*ht,col=Green,border=NA)
red= seq(crit.value,mu+3*SEM,length.out=50)
d = c(dnorm(red,mu,SEM),0)
polygon(c(red,crit.value),d + I*ht,col="red",border=NA)
text(mu+3*SEM, I*ht,
toString(
round(100*pnorm(crit.value,mu,SEM,lower.tail=FALSE)) ),
col="red")
if(I==0) text(mu-2*SEM, (I+0.5)*ht,
toString(
round(100*pnorm(crit.value,mu,SEM)) ),
col=Green)
points(mu,I*ht,pch=19,
cex=0.25+0.4*(pct.w==round(pct.w)) )
points(mu,-ht*1.0,pch=19,cex=0.25)
if(pct.w==round(pct.w)) text(mu,-ht/1.3,
paste(toString(pct.w),"%"),cex=0.75)
if(pct.w==round(pct.w)) points(mu,
-ht*1.0,pch=19,cex=0.75)
if(I==0) text(-0.54,-1.15*ht,
"MILK",adj=c(0.5,1) )
I = I+1
}
} # fig1
fig2= FALSE
if(fig2){
# 1% fixed , vary n
ht=1.6*dnorm(0,0,sigma/sqrt(20))
mu.1pct = 0.99* mu.m
par(mfrow=c(1,1),mar = c(5,0.001,0.001,0.001) )
plot(c(mu.m-4.25*SEM,mu.1pct+3*SEM),c(-1.5*ht,16*ht),
col="white",xlab="Freezing point (degrees C)")
segments(mu.1pct,0,mu.1pct,
12*ht,lwd=0.5,col="grey60")
text(-0.51,3*ht,"Probability (pct.)
of exceeding cutoff",adj=c(1,0),col="red")
text(-0.555,16*ht,
expression(paste(
sigma,
" = 0.0080;  SEM = ",
sigma/sqrt(n))) ,
adj=c(0,0))
text(-0.555,15*ht,
"cutoff = -0.54 + 1.645*SEM (alpha=0.05, 1 sided alternative)",
adj=c(0,0))
text(-0.555,16*ht,
expression(paste(
sigma,
" = 0.0080;  SEM = ",
sigma/sqrt(n))) ,
adj=c(0,0))
n=5
sem = sigma/sqrt(n)
n80 = round(( ( 1.645+0.84)^2 ) * (sigma/0.0054)^2,1)
I=0
for ( m in c(1:2,n80/5,3,4) ){
if(m==1) text(-0.52,-ht/2,"Added Water",
cex=0.75, adj=c(0,0.5))
SEM = sem/sqrt(m)
text(-0.55,(I+1.0)*ht,
paste("n =",toString(n*m)) ,
adj=c(1,0))
crit.value = mu.m + 1.646 * SEM
rect(mu.m-4*sem,(I-0.8)*ht, mu.1pct+3*sem,(I+2.2)*ht)
# null
green= seq(mu.m-3*SEM,crit.value,length.out=50)
d = c(dnorm(green,mu.m,SEM),0)
polygon(c(green,crit.value),d + I*ht,col=Green,border=NA)
text(-0.548,(I+1.0)*ht,
paste("SEM = ",
toString(round(SEM,4))),
cex=0.65,adj=c(0,0))
red= seq(crit.value,mu.m+3*SEM,length.out=50)
d = c(dnorm(red,mu.m,SEM),0)
polygon(c(red,crit.value),d + I*ht,col="red",border=NA)
points(mu.m,I*ht,cex=0.3,pch=19)
#alt
green= seq(mu.1pct-3*SEM,
crit.value,length.out=50)
d = c(dnorm(green,mu.1pct,SEM),0)
polygon(c(green,crit.value),d + (I+1)*ht,col=Green,border=NA)
points(mu.1pct,(I+1)*ht,cex=0.3,pch=19)
red= seq(crit.value,mu.1pct+3*SEM,length.out=50)
d = c(dnorm(red,mu.1pct,SEM),0)
polygon(c(red,crit.value),d + (I+1)*ht,col="red",border=NA)
segments(crit.value,I*ht ,
crit.value,(I+1)*ht,lwd=0.5,col="red")
arrows(mu.m,(I-0.25)*ht,
crit.value,(I-0.25)*ht,length=0.05,
code=3,angle=20,col=Green,lwd=1.5)
arrows(crit.value,(I+1-0.25)*ht,
mu.1pct,(I+1-0.25)*ht,length=0.05,
code=3,angle=15,col="red",lwd=1.5)
x = mu.1pct+1*SEM
y = (I+1)*ht+0.8*max(d)
if(m!=round(m))rect(
x - 0.0011,y-0.10*ht,
x + 0.0011,y+0.60*ht,
col="beige",border="purple",
lwd=2)
text(x, y,
paste(toString( round(100*pnorm(
crit.value,mu.1pct,
SEM,lower.tail=FALSE)) ),"%",sep=""),
adj=c(0.5,0),col="red")
if(m!=round(m)){
text(-0.5305,(I+1.55)*ht,"qnorm(0.8,
lower.tail=FALSE)
-0.84",		cex=0.65,family="mono",adj=c(0,0.5),col="red")
x = (crit.value+mu.1pct)/2
lines(x+c(0,0,0.005),
(I+1-0.25+c(0,-.3,-.3))*ht,col="red")
text(x+0.005,
(I+1-0.25-0.3)*ht,
"0.84 * SEM",col="red",
adj=c(-0.1,0.5),cex=0.65)
text(-0.553,(I-0.4)*ht,"qnorm(0.05,
lower.tail=FALSE)
1.96",		cex=0.65,family="mono",adj=c(0,0),col=Green)
x = (crit.value+mu.m)/2
lines(x+c(0,0,-0.005),
(I-0.25+c(0,-.15,-.15))*ht,col=Green)
text(x-0.005,
(I-0.25-0.15)*ht,
"1.645 * SEM",col=Green,
adj=c(1.1,0),cex=0.65)
sum <- "(1.645 + 0.84)"
txt = substitute(
paste("n = ",
s^2,
phantom(0),
scriptstyle(x),
phantom(0),
(sigma/Delta)^2),
list(s = sum))
rect(-0.554,(I+1.55)*ht,
-0.5445,(I+2.17)*ht,
col="beige",border="purple",
lwd=4)
text(-0.553,(I+1.6)*ht,txt,
adj=c(0,0), cex=0.75)
arrows(mu.m,   (I-0.6)*ht,
mu.1pct,(I-0.6)*ht,length=0.05,
code=3,angle=20,lwd=1.5)
text(mu.1pct,(I-0.6)*ht,
expression(paste(
Delta, " = 1.645*SEM + 0.84*SEM")),
adj=c(-0.1,0.5), cex=0.75
)
} # special
I = I+3
}
n80 = ( ( 1.645+0.84)^2 ) * (sigma/0.0054)^2
points(mu.m,   -1.5*ht,pch=19,cex=0.65 )
text(mu.m,-ht,"100% milk",cex=0.75)
points(mu.1pct,-1.5*ht,pch=19,cex=0.65)
text(mu.1pct,-ht,"1 % water",cex=0.75)
text((mu.m+mu.1pct)/2,-1.5*ht,
expression(paste(Delta," = 0.0054")),
cex=0.85)
arrows(mu.m,-1.8*ht,
mu.1pct,-1.8*ht,length=0.05,
code=3,angle=20,lwd=1.5)
} # end fig 2
mosaic::t_test(~age, HELPrct)
n <- length(reaction.times)
SEM <- sd(reaction.times)/sqrt(n)
reaction.times <- c(325,327,357,299,378)/1000
n <- length(reaction.times)
SEM <- sd(reaction.times)/sqrt(n)
n <- length(reaction.times)
SEM <- sd(reaction.times)/sqrt(n)
(SEM <- sd(reaction.times)/sqrt(n))
multiple.for.95pct <- stats::qt(p = c(0.025, 0.975), df = n-1)
(multiple.for.95pct <- stats::qt(p = c(0.025, 0.975), df = n-1))
by_hand_CI <- mean(reaction.times) + multiple.for.95pct * SEM
round(by_hand_CI, 3)
qt(p = c(0.025, 0.975), df = n-1, ncp = mean(reaction.times)/SEM)
qt(p = c(0.025, 0.975), df = n-1, ncp = mean(reaction.times)*SEM)
qt(p = c(0.025, 0.975), df = n-1, ncp = SEM/mean(reaction.times))
coef(fit)
fit <- stats::lm(reaction.times ~ 1)
summary(fit)
stats::confint(fit)
coef(fit)
mosaic::xpt(q = c(-24.56, 24.56), df = n-1)
mosaic::xpt(q = c(-24.56, 24.56), df = n-1, lower.tail=F)
mosaic::xpt(q = 24.56, df = n-1, lower.tail=F)
mosaic::t.test(reaction.times ~ 1)
mosaic::t.test(reaction.times)
mosaic::t.test(reaction.times~1)
mosaic::t.test(reaction.times~0)
mosaic::t.test(reaction.times~1)
mosaic::t.test(reaction.times)
lm(~reaction.times)
lm(reaction.times)
lm(reaction.times~)
lm(reaction.times~1)
s_dist <- do(10000) * mean( ~ reaction.times, data = resample(reaction.times))
df_react <- as.data.frame(reaction.times)
df_react
s_dist <- do(10000) * mean( ~ reaction.times, data = resample(df_react))
# 95% CI
CI_95 <- quantile(~ mean, data = s_dist, probs = c(0.025, 0.975))
# plot sampling distribution
hist(s_dist$mean, breaks = 50, col = "#56B4E9",
main="",
xlab = "mean depth of the ocean (100m) from each bootstrap sample")
# draw red line at the sample mean
abline(v = mean_depth, lty =1, col = "red", lwd = 4)
# draw red line at the sample mean
abline(v = mean(reaction.times), lty =1, col = "red", lwd = 4)
# draw black dotted lines at 95% CI
abline(v = CI_95[1], lty =2, col = "black", lwd = 4)
abline(v = CI_95[2], lty =2, col = "black", lwd = 4)
# include legend
library(latex2exp)
mean(reaction.times)
# include legend
library(latex2exp)
legend("topleft",
legend = c(TeX("$\\bar{y} = 0.3372$"),
sprintf("95%% CI: [%.3f, %.3f]",CI_95[1], CI_95[2])),
lty = c(1,1),
col = c("red","black"), lwd = 4)
data.frame(reaction.times)
dev.off()
pacman::p_ver("roxygen2")
install.packages("roxygen2")
