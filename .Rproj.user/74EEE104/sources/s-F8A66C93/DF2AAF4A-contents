---
title: "Combined Gallix Model"
author: "by Sahir Bhatnagar"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: false
    number_sections: true
    toc_depth: 4
    keep_md: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, fig.width = 11, fig.height = 8) 
```

```{r, echo=FALSE, results='hide', fig.keep='none'}
options(digits = 4, scipen = 2)
knitr::read_chunk("/home/sahir/Dropbox/consulting/gallix/jobtest/bin/data.R")
knitr::read_chunk("/home/sahir/Dropbox/consulting/gallix/jobtest/bin/packages.R")
knitr::read_chunk("/home/sahir/Dropbox/consulting/gallix/jobtest/bin/functions.R")

max_lesion_volume <- 50
lambda.type <- "lambda.min"
set.seed(1234)
```

```{r packages}
```

```{r defaults}
```

```{r functions}
```


```{r load-data}
```


# Definition of Models

## Combined Gallix Model (CGM)

The combined Gallix model (CGM) contains the following variables:

```{r}
knitr::kable(combined_gallix)
```


## Inner Features Only (IFO)

We compare the CGM with the model with Inner Features Only (IFO) which contains the following variables:


```{r}
knitr::kable(inner_names_wo5)
```





# Results

Note that `wo6` means without the border curvature. `woconcl` means without the conclusion human variable. 

```{r}
root <- "~/Dropbox/consulting/gallix/jobtest/"

fits_delayed <- readRDS(paste0(root, "results/delayed_human_texture_results_threshold_0_Oct16.rds"))
fits <- fits_delayed[[1]] # selecting ranger method. other methods also included in fits_delaayed
resamps <- resamples(fits)

pacman::p_load(tidyr)
DT <- resamps$values

DT <- DT %>% 
  gather(key = "key", value = "value", -Resample) %>% 
  separate(col = "key", into = c("Model","Metric"), sep = "~") 

# res <- DT %>% 
#   group_by(Model, Metric) %>% 
#   summarise(mean = mean(value), se = sd(value), 
#             lower = mean(value) - quantile((value - mean(value)) / sd(value), probs = 0.975) * sd(value),
#             upper = mean(value) - quantile((value - mean(value)) / sd(value), probs = 0.025) * sd(value))

# this gives upper bounds of 1 for sens and spec so use simple percentile CIs 
res <- DT %>% 
  group_by(Model, Metric) %>% 
  summarise(estimate = median(value), se = sd(value), 
            conf.low = quantile(value, probs = 0.025),
            conf.high = quantile(value, probs = 0.975)) %>% 
  mutate(term = Model, model = Metric)

pacman::p_load(dotwhisker)
pacman::p_load(viridis)

plotMetric <- function(results, metric = c("Brier", "Kappa", "LogLoss", "NPV", "PPV", "ROC", "Sens", "Spec"),
                       title = "Sensitivity Based on 1999 Bootstrap Samples",
                       # colls = viridis::viridis(16, end = 1, direction = -1),
                       colls = rep("black", 16)){

  gg_sy <- gg_sy <- theme(legend.position = "bottom", axis.text = element_text(size = 20),
                          axis.title = element_text(size = 20), 
                          legend.text = element_text(size = 20), 
                          legend.title = element_text(size = 20))
  
  metric <- match.arg(metric)
  
  dwplot(results[results$Metric %in% metric,],
         dot_args = list(size = 2, color = colls),
         whisker_args = list(size = 1.2, color = colls),
         order_vars = 
           results[results$Metric %in% metric,]$Model[order(results[results$Metric %in% metric,]$estimate, 
                                                            decreasing = TRUE)]) + 
    theme_bw() + xlab("Median (95% CI)") + ylab("") +
    ggtitle(title) +
    gg_sy + 
    theme(plot.title = element_text(face="bold", size = 20),
          legend.position = c(0.007, 0.01),
          legend.justification = c(0, 0), 
          legend.background = element_rect(colour="grey80"),
          legend.title = element_blank())   
}



plotMetric(results = res, metric = "ROC", 
           title = "AUC Based on 1999 Bootstrap Samples")
plotMetric(results = res, metric = "Sens", 
           title = "Sensitivity Based on 1999 Bootstrap Samples")
plotMetric(results = res, metric = "Spec",
           title = "Specificity Based on 1999 Bootstrap Samples")
plotMetric(results = res, metric = "PPV",
           title = "Positive Predicted Value Based on 1999 Bootstrap Samples")
plotMetric(results = res, metric = "NPV",
           title = "Negative Predicted Value Based on 1999 Bootstrap Samples")
plotMetric(results = res, metric = "Brier",
           title = "Brier Score Based on 1999 Bootstrap Samples")
```


## Variable Importance from the RoboGallix Model

```{r, fig.height=12}
set.seed(234)
source(paste0(root, "bin/data_human_texture.R"))
source(paste0(root, "bin/functions.R"))

j <- 0
# j <- as.numeric(as.character(commandArgs(trailingOnly = T)[1]))
print(j)
min_lesion_volume <- j ^ 3
max_lesion_volume <- Inf
# method <- as.character(commandArgs(trailingOnly = T)[2])
method <- "glmnet"
print(method)

## ---- create-thresholded-data -------------------------------------------------

thresh_data <- create_data(data = DT, 
                           combined_gallix = combined_gallix,
                           min_lesion_volume = min_lesion_volume,
                           max_lesion_volume = max_lesion_volume, 
                           border_names = border_names, 
                           border_names_wo6 = border_names_wo6,
                           border_names_6 = border_names_6,
                           inner_names = inner_names, 
                           inner_names_wo5 = inner_names_wo5,
                           inner_names_5 = inner_names_5,
                           reinhold = reinhold,
                           vargas = vargas,
                           gallix = gallix,
                           hoeffel = hoeffel,
                           reinhold_wo6 = reinhold_wo6,
                           vargas_wo6 = vargas_wo6, 
                           gallix_wo6 = gallix_wo6, 
                           hoeffel_wo6 = hoeffel_wo6, 
                           reinhold_woconcl = reinhold_woconcl, 
                           vargas_woconcl = vargas_woconcl, 
                           gallix_woconcl = gallix_woconcl, 
                           hoeffel_woconcl = hoeffel_woconcl)

pacman::p_load(ranger)
rf.sim <- ranger(HGP ~ ., data = thresh_data$RoboGallix, importance = "permutation")
rr <- importance_pvalues(rf.sim, method = "altmann", formula = HGP ~ ., data = thresh_data$RoboGallix)

par(las=2) # make label text perpendicular to axis
par(mar=c(5,8,4,2)) # increase y-axis margin.
barplot(-log10(rr[order(rr[,2], decreasing = T),2]),
        horiz = TRUE, col = viridis::viridis(n = nrow(rr), direction = -1),
        xlab = "-log10(pvalue)")
```



## Variable Importance from the RoboReinhold Model


```{r, fig.height=12}
set.seed(2345)
pacman::p_load(ranger)
rf.sim <- ranger(HGP ~ ., data = thresh_data$RoboReinhold, importance = "permutation")
rr <- importance_pvalues(rf.sim, method = "altmann", formula = HGP ~ ., data = thresh_data$RoboReinhold)

par(las=2) # make label text perpendicular to axis
par(mar=c(5,8,4,2)) # increase y-axis margin.
barplot(-log10(rr[order(rr[,2], decreasing = T),2]),
        horiz = TRUE, col = viridis::viridis(n = nrow(rr), direction = -1),
        xlab = "-log10(pvalue)")
```



## Variable Importance from the Curvature Border Model


```{r}
set.seed(2345)
pacman::p_load(ranger)
rf.sim <- ranger(HGP ~ ., data = thresh_data$Curvature_Border, importance = "permutation")
rr <- importance_pvalues(rf.sim, method = "altmann", formula = HGP ~ ., data = thresh_data$Curvature_Border)

par(las=2) # make label text perpendicular to axis
par(mar=c(5,8,4,2)) # increase y-axis margin.
barplot(-log10(rr[order(rr[,2], decreasing = T),2]),
        horiz = TRUE, col = viridis::viridis(n = nrow(rr), direction = -1),
        xlab = "-log10(pvalue)")
```
