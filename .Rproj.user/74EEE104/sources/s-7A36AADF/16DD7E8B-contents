reaction.times = c(325,327,357,299,378)/1000

( summary(reaction.times) )

( round( sd(reaction.times), 3) )

( n = length(reaction.times) )

( SEM = sd(reaction.times)/sqrt(n) )

( round(SEM,3) )

( multiple.for.95pct = qt(0.975,n-1))

( multiple.for.95pct.if.n.of.100 = qt(0.975,100-1))

( round(
   mean(reaction.times) + 
    c(-multiple.for.95pct,0,multiple.for.95pct) * SEM,
  3) )
  
  
## fitting mu using mother of all regression models
## (the `intercept-only' or `1-constant' model)
## (fitted by Least Squares)

## E[y] = mu * 1
  
  fitted.model = lm( reaction.times ~ 1)
  
  summary( fitted.model )
  
  library(MASS)
  
  round( confint(fitted.model), 3 ) 
## Interestingly, lm does not give CI's automatically
## It does give p-values, even if H_0 is silly
  
  
  1- pt(24.56,n-1) # is the probability ABOVE 24.56
  
  pt(-24.56,n-1) # is the probability BELOW -24.56
  
  2*(1-pt(abs(24.56),n-1)) # is the probability 
## of a more extreme result in EITHER direction
## (but not that relevant here, since a negative mu is
## even more silly than a zero mu)

## R gives CI if you ask for the test

t.test(reaction.times)



##########  paired t-test


library(lme4)

summary(sleepstudy)

IndividuallyFittedSlopes=rep(NA,18)
Subject=rep(NA,18)
IndividualDiffs.Day1.minus.Day0 =rep(NA,18)
I=0
for(ss in unique(sleepstudy$Subject)){
    X= x[sleepstudy$Subject==ss,2]
	Y= x[sleepstudy$Subject==ss,1]
	I=I+1
	IndividuallyFittedSlopes[I] = 
	 round(as.numeric( (lm(Y ~ X)$coefficients[2]) ),1)
	Subject[I]= ss
	IndividualDiffs.Day1.minus.Day0[I] = round(Y[2] - Y[1],0)
} 

summary(IndividuallyFittedSlopes)

sd(IndividuallyFittedSlopes)

t.test(IndividuallyFittedSlopes)

t.test(IndividualDiffs.Day1.minus.Day0)



