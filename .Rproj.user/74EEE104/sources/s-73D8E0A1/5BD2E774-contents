# jim 2018.08.15

# toggle  overview and  detailed.eg On OFF as needed

expit = function(x) exp(x)/(1+exp(x)) # antilogit

overview=TRUE
if(overview) {
	
par(mfrow=c(1,1),mar = rep(0.01,4))

plot(c(0,4),c(1,4),col="white",axes=FALSE,frame=TRUE)


segments(0.5,1:4,4,1:4,col="blue",lwd=2)
segments(1:4,1,1:4,4,col="blue",lwd=2)

CEX=0.5

x=0.5
dy=0.2
dx=0.25
for(row in 3:1) {
	if(row==3) {txt = expression(mu);TXT="MEAN"}
	if(row==2) {txt = expression(pi);TXT="PROPORTION"}
	if(row==1) {txt = expression(lambda);TXT="RATE"}
	text(x,row+.5,txt)
	text(x-0.05,row+.5,TXT,adj=c(1,0.5),cex=CEX)
	if(row==1)text(x-0.05,row+.45,"(Number of events
per unit time)",
	  adj=c(1,1),cex=CEX)
	arrows(x+dx, row+dy, x+dx,row+1-dy,angle=30,
	length=0.07-0.07*(row==2),code=2+(row==3))
	if(row<3) text(x+dx,row+dy,"0",adj=c(1.5,0.5))
	if(row==2)text(x+dx,row+1-dy,"1",adj=c(1.5,0.5))
}

dy=0.2
for(col in 1:3) {
	x=col+0.5; 
	if(col==1) dx=0.05
	if(col==2) dx=0.3
	for(row in 3:1){
		segments(col+0.5-dx,row+dy,col+0.5+dx,row+dy)
		if(col>1)text(col+0.5-dx,row+dy,"0",adj=c(0.5,1.75))
		if(col==2) text(col+0.5+dx,row+dy,"1",adj=c(0.5,1.75))
		if(col==3) {
			xx=seq(col+0.5-dx,col+0.5+dx,dx/10)
			segments(xx,row+dy,xx,row+dy-0.03)       
		}
		text(col+0.5,row+dy/3,"X",font=2)
		if(col==1) { m= (2/3)*(1-2*dy)
		    points(col+0.5,row+dy+m,pch=19,cex=0.6)
		}
		if(col==2) { m= ((1:2)/3)*(1-2*dy)
		    points(col+0.5+c(-dx,dx),row+dy+m,pch=19,cex=0.6)
		}
		if(col==3) { m= ((3:12)/14)*(1-2*dy)
			        xx=seq(-dx,dx,length.out=10)
		    points(col+0.5+xx,row+dy+m,pch=19,cex=0.6-0.3*(row<3))
		    if(row==2){
		    	  logit = seq(-3,3,length.out=10)
		      m=expit(logit)*(1-2*dy)
		      points(col+0.5+xx,row+dy+m,pch=19,cex=0.6)
		    }
		    if(row==1){
		     log.rate = seq(-1.7,0.1,length.out=10)
		      m=exp(log.rate)*(1-2*dy)
		      points(col+0.5+xx,row+dy+m,pch=19,cex=0.6)
		    }
		}
	} 
}

#Baldi and Moore Ed. 3

BM=matrix(NA,3,3)
BM[3,1]="1,2, 13,14, 17"
BM[3,2]="4, 10, 18"
BM[3,3]="4, 23"

BM[2,1]="1, 12,13,14, 19"
BM[2,2]="5, 20,21,22"
BM[2,3]="28?"

BM[1,1]="p300-306"
BM[1,2]="-----"
BM[1,3]="-----"

for(row in 1:3) {
	for(col in 1:3) {
		text(col+1,row+1,BM[row,col],adj=c(1.1,1.5))
	}
}

} # overview

##########################


detailed.eg=FALSE


if(detailed.eg) {
	
par(mfrow=c(1,1),mar = rep(0.01,4))

plot(c(0,1),c(0,1),col="white",axes=FALSE,frame=TRUE)

plot(c(0,1),c(0,1),col="white",axes=FALSE,frame=TRUE)

# 0/1

setwd("/Users/jameshanley/Dropbox/Courses/bios601/Surveys/Oceanography")
csv=list.files(pattern = ".csv")
f25=read.csv(csv[1])[1:25,2:4]
f25$water=1*(f25$alt<0)
plot(c(0,1),c(0,1),
xlim=c(0,1),ylim=c(0,1),col="white",axes=FALSE,frame=TRUE)

x=0.03; dx=0.04; y=0.92; dy=1/30; CEX=0.6
text(x+dx,y+dy,
"PARAMETER: proportion of Earth's
surface that is covered by water.

Alt/Depth at n=25 random locations",
 adj=c(0.5,0),family="mono",cex=CEX,font=3,col="red")
text(x,y,"lon",adj=c(1,0),family="mono",cex=CEX,font=3)
text(x+dx,y,"lat",adj=c(1,0),family="mono",cex=CEX,font=3)
text(x+2*dx,y,"alt",adj=c(1,0),family="mono",cex=CEX,font=3)
text(x+2.75*dx,y,"water",adj=c(0.5,0),family="mono",cex=CEX,font=2)

n=25
for(i in 1:n){ 
text(x,y-i*dy,toString(round(f25[i,1],2)),
     adj=c(1,0),family="mono",cex=CEX,font=3)
text(x+dx,y-i*dy,toString(round(f25[i,2],2)),
     adj=c(1,0),family="mono",cex=CEX,font=3)
text(x+2*dx,y-i*dy,toString(round(f25[i,3],0)),
     adj=c(1,0),family="mono",cex=CEX)
text(x+2*dx,y-i*dy,toString(round(f25[i,3],0)),
     adj=c(1,0),family="mono",cex=CEX)
text(x+2.75*dx,y-i*dy,toString(round(f25[i,4],0)),
     adj=c(0.5,0),family="mono",cex=CEX,font=2) 
}
segments(x+4.5*dx,-1,x+4.5*dx,2,col="grey70",lwd=5,lty="dotted")

x=x+6.5*dx;
text(x+dx,y+3*dy,
"Distribution of raw data,
summary statistics, and
Confidence Interval (CI)
for PARAMETER",
 adj=c(0,1),family="mono",cex=CEX,font=3,col="red")

y=0.75; dy=0.20
 
lines(x+c(0,0,1)*2*dx,y+c(1,0,0)*dy)
text(x,y,"0 (No)",adj=c(1.25,0.5),cex=CEX)
text(x,y+dy,"1 (Yes)",adj=c(1.25,0.5),cex=CEX)
text(x,y+dy,"Water",adj=c(1.25,-1.25),font=2,cex=CEX)
for(j in 0:10) segments(x,y+(j/10)*dy,
                   x+dx/10,y+(j/10)*dy)
for(j in 0:20) segments(x,y+(j/20)*dy,
                  x+dx/20,y+(j/20)*dy)
                     
UL=mean(f25$water)+c(-1.96,0,1.96)*
              sd(f25$water)/sqrt(n)
text(x+dx/2+0.005,y+UL[2]*dy,
"mean of n 0's and 1's
(proportion of 1's in sample)",
 adj=c(0,0.5),family="mono",cex=CEX,font=3,col="red")

text(x+dx/2,y+UL[3]*dy,
"U",
 adj=c(1.5,0.5),family="mono",cex=CEX,font=3,col="red")
text(x+dx/2,y+UL[1]*dy,
"L",
 adj=c(1.5,0.5),family="mono",cex=CEX,font=3,col="red")

text(x+dx/5,y+0.25*dy,
"L, point, and U are the point est.,
and Lower & Upper Limits of 95%
Confidence Interval for PARAMETER",
 adj=c(-0.1,0.5),family="mono",cex=CEX,font=3,col="red")
                      
segments(x+dx/2,y+UL[1]*dy,x+dx/2,y+UL[3]*dy)            
n.1=sum(f25$water)
points(x+dx/2,y+dy,cex=0.6*sqrt(n.1))
text(x+dx/2,y+dy,toString(n.1),cex=CEX)
n.0=sum(1-f25$water)
points(x+dx/2,y,cex=0.6*sqrt(n.0))
text(x+dx/2,y,toString(n.0),cex=CEX)
points(x+dx/2,y+dy*mean(f25$water),pch=19,cex=CEX)


table(f25$water)     # distribution of 0's and 1's
round(mean(f25$water),2) # mean of the 0's and 1's
round(quantile(f25$water,(1:3)/4),2) # Q25,Q50,Q75
round(sd(f25$water),2) # St. Devn. of 0's and 1's
(n=length(f25$water))  # sample size (n)

# roll-your-own 'large-sample' CI for PARAMETER

round(mean(f25$water)+c(-1.96,0,1.96)*
              sd(f25$water)/sqrt(n),2)
                         
# 'Exact' Binomial conf. interval (?binom.test)
( n.1=sum(f25$water) )
binom.test(n.1, n,conf.level = 0.95)

x=x+dx;

text(x-2*dx,y-dy/5,
"> table(f25$water)     # distribution of 0's and 1's
 0  1 
 9 16 
> round(mean(f25$water),2) # mean of the 0's and 1's
[1] 0.64
> round(quantile(f25$water,(1:3)/4),2) # Q25,Q50,Q75
25% 50% 75% 
  0   1   1 
> round(sd(f25$water),2) # St. Devn. of 0's and 1's
[1] 0.49
> (n=length(f25$water))  # sample size (n)
[1] 25
 
** roll-your-own 'large-sample' CI for PARAMETER **
 
> round(mean(f25$water)+c(-1.96,0,1.96)*
+               sd(f25$water)/sqrt(n),2)
[1] 0.45 0.64 0.83 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                          
** 'Exact' Binomial conf. interval (?binom.test) **

> ( n.1=sum(f25$water) )
[1] 16
> binom.test(n.1, n,conf.level = 0.95)

	Exact binomial test

data:  n.1 and n
number of successes = 16, number of trials = 25, 
p-value = 0.2295; alternative hypothesis: true 
probability of success is not equal to 0.5.

95 percent confidence interval:
 0.4252063 0.8202832 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
sample estimates:
probability of success: 0.64 ",
adj=c(0,1),cex=CEX,family="mono")


segments(x+7*dx,-1,x+7*dx,2,col="grey70",lwd=5,lty="dotted")

##########

x=x+8*dx; y = 0.96  

text(x,y,
"PARAMETER estimation via simplest regression
model, one with just one (intercept) term
(2 versions, less and more specific/sophisticated)",
 adj=c(0,0),family="mono",cex=CEX,font=3,col="red")

# *1* NOT TELLING R that Y's are limited to 0s and 1's **#
 
blind.fit = lm(f25$water ~ 1) # ordinary regression
( output = summary(blind.fit) )
round(confint(blind.fit),2)

# *2*     TELLING R that Y's are limited to 0s and 1's **#

logistic.regrn.fit = 
  glm(f25$water ~ 1,family=binomial) 
summary( logistic.regrn.fit )

expit = function(x) exp(x)/(1+exp(x)) # antilogit

(PARAMETER.Est = expit(logistic.regrn.fit$coefficients) )
( CI.in.logit.scale = confint(logistic.regression.fit) )
( CI.for.PARAMETER = round( expit(CI.in.logit.scale),2))


text(x,y-dy/5,
"> # *1* NOT TELLING R that Y's are limited to 0s and 1's **#
>  
> blind.fit = lm(f25$water ~ 1) # ordinary regression
> ( output = summary(blind.fit) )

Residuals:
   Min     1Q Median     3Q    Max 
 -0.64  -0.64   0.36   0.36   0.36 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept)  0.64000    0.09798   6.532 9.35e-07 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.4899 on 24 degrees of freedom

> round(confint(blind.fit),2)
            2.5 % 97.5 %
(Intercept)  0.44   0.84 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
> 
> # *2*     TELLING R that Y's are limited to 0s and 1's **#
> 
> logistic.regrn.fit = 
+   glm(f25$water ~ 1,family=binomial) 
> summary( logistic.regrn.fit )

Coefficients:
            Estimate Std. Error z value Pr(>|z|)
(Intercept)   0.5754     0.4167   1.381    0.167

    Null deviance: 32.671  on 24  degrees of freedom
Residual deviance: 32.671  on 24  degrees of freedom

> 
> expit = function(x) exp(x)/(1+exp(x)) # antilogit
> 
> (PARAMETER.Est = expit(logistic.regrn.fit$coefficients) )
(Intercept) 
       0.64 
> ( CI.in.logit.scale = confint(logistic.regression.fit) )
Waiting for profiling to be done...
     2.5 %     97.5 % 
-0.2213482  1.4353591 
> ( CI.for.PARAMETER = round( expit(CI.in.logit.scale),2))
 2.5 % 97.5 % 
  0.44   0.81 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",
adj=c(0,1),cex=CEX,family="mono")

} # detailed

